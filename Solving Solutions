import json

# Occurrence class is used in hidden single, hidden pair and hidden triple
# It stores the counters of candidates in each unit (row, column or box) along with their locations 
# in the board
class Occurrence:
    
    # The init() sets the initial counter and positions for later use.
    def __init__(self):
        self.counter = 0
        
        # The positions variable is needed for the Hidden Pairs function.
        self.positions = [(0, 0) for x in range(3)]
        
    def increment(self):
        self.counter += 1
       
    def get_counter(self):
        return self.counter
    
    # set_position() sets the candidate's board position (row, col) in the Occurence.
    def set_position(self, pos_num, row, col):
        self.positions[pos_num-1] = (row, col)
    
    def get_position(self, pos_num):
        return self.positions[pos_num-1]
    
    def list_positions(self):
        return self.positions

# The Cell class refers to a cell in the board.
class Cell:
    
    # Initializes the board
    def __init__(self, value):
        if value == "*" or  value == 0:
            self.value = 0
            self.candidate = [1, 2, 3, 4, 5, 6, 7, 8, 9]  # value is not provided, 
                                                          # all numbers are candidates at the beginning
        else:
            self.value = value # a value is provided
            self.candidate = [] # cell is already solved, so no candidates
    
    # Sets the cell's value and clear the candidates
    def set(self, value):
        self.value = value
        self.candidate.clear()

    # Returns the cell's value
    def get(self):
        return self.value

    def is_empty(self):
        return self.value == 0

    # return true if specified element is in the candidates list
    def contains(self, elem):
        return self.candidate.count(elem) != 0

    # adds the specified element to the candidates list
    def add(self, elem):
        if not self.contains(elem):
            self.candidate.append(elem)

    # removes the specified element from candidates list
    def delete(self, elem):
        if self.contains(elem):
            self.candidate.remove(elem)

    # returns the candidates list
    def list(self):
        return self.candidate

    # returns the number of elements in the candidates list
    def count(self):
        return len(self.candidate)


# The Board class implements the Sudoku solution strategies
class Board:
    
    # Initializes a 9X9 board. If a board (two dimensional array) is provided then it sets 
    # the given values in the Board
    def __init__(self, board):
        self.board = [[Cell(0) for x in range(9)] for y in range(9)] # initializes with zeros
        
        if board != []: 
            for i in range(9):
                for j in range(9):
                    if str(board[i][j]).isnumeric() and board[i][j] > 0:
                        self._set(i, j, board[i][j]) #inserts the value in the board
    
    # This function sets the specified value at the given positions.
    # It also removes the value from all the units (row, column, box)            
    def _set(self, cell_row, cell_col, value):
        self.board[cell_row][cell_col].set(value) # calls Cell's function to update the value
        
        for col in range(9): # loops through the columns of the specified row
            if self.board[cell_row][col].is_empty(): # call Cell's function to check if the cell is empty
                self.board[cell_row][col].delete(value) # call Cell's function to remove value 
                                                        # from candidates list
                        
        for row in range(9): # loops through the rows of the specified column
            if self.board[row][cell_col].is_empty():
                self.board[row][cell_col].delete(value)
        
        for row in range((cell_row // 3) * 3, (cell_row // 3) * 3 + 3): # loops through the 3X3 box
            for col in range((cell_col // 3) * 3, (cell_col // 3) * 3 + 3):
                if self.board[row][col].is_empty():
                    self.board[row][col].delete(value)

    # prints the contents of the board
    def print(self):
        for i in range(9):
            print("-" * 37)
            
            for j in range(9):
                print(f"| {self.board[i][j].get()} ", end ="")
                
            print("|")
            
        print("-" * 37)

    # prints candidates list of each cell in the board
    def print_candidates(self):
        for i in range(9):
            print()
            
            for j in range(9):
                print(f"{self.board[i][j].list()}, ", end ="")
        
        print()

    # converts board's contents (values only) into json
    def toJSON(self):
        json_data = {'board': []}
        for row in self.board:
            row_data = []
            for cell in row:
                row_data.append(cell.value)
                
            json_data['board'].append(row_data)
            
        return json.dumps(json_data)
    
    # converts board's contents (values and candidates) into json
    def toJSON_Full(self):
        json_data = {'board': []}
        for row in self.board:
            row_data = []
            for cell in row:
                row_data.append(cell.value)
                row_data.append(cell.list())
                
            json_data['board'].append(row_data)
            
        return json.dumps(json_data)
    
    # returns true if board is full
    def is_full(self):
        for row in range(9):
            for col in range(9):
                if self.board[row][col].is_empty(): # calls Cell's function to check if cell is empty
                    return False
                    
        return True

    # implements hidden single solution strategy
    def hidden_single(self, retries):
        # retries until board is filled or max retries has exhausted
        if self.is_full() or retries == 0:
            return retries
        
        for row in range(9): # loops through each row of the board
            occurrence = [Occurrence() for x in range(9)] # creates an empty Occurence
            
            for col in range(9): # loops through each column of the row
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list() # call Cell's list function to get candidates 
                
                    for elem in candidates: # loop through each candidate
                        occurrence[elem-1].increment() # increments the counter at the candidate's pos
                        occurrence[elem-1].set_position(1,row, col) #sets the cell pos in the Occurrence
            
            for x in range(9): # after marking is done, loop through each Occurence
                if occurrence[x].get_counter() == 1: # counter = 1 means hidden single
                    (i_row, i_col) = occurrence[x].get_position(1) # get cell position
                    self._set(i_row, i_col, x + 1) # sets the cell's value to the hidden single candidate
    
        for col in range(9): # loop through columns
            occurrence = [Occurrence() for x in range(9)]
            
            for row in range(9): # loop through each row of the column
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list()
                
                    for elem in candidates:
                        occurrence[elem - 1].increment()
                        occurrence[elem - 1].set_position(1,row, col)
            
            for x in range(9):
                if occurrence[x].get_counter() == 1:
                    (i_row, i_col) = occurrence[x].get_position(1)
                    self._set(i_row, i_col, x + 1) #sets the cell's value to the hidden single candidate 
            
        for box_row in range(0, 9, 3): # loop through each of the 9 boxes
            for box_col in range(0, 9, 3):
                occurrence = [Occurrence() for x in range(9)]
            
                for row in range(box_row, box_row + 3): # loop through each cell of 3X3 box
                    for col in range(box_col, box_col + 3):
                        if self.board[row][col].is_empty():
                            candidates = self.board[row][col].list()
                
                            for elem in candidates:
                                occurrence[elem - 1].increment()
                                occurrence[elem - 1].set_position(1,row, col)
            
                for x in range(9):
                    if occurrence[x].get_counter() == 1:
                        (i_row, i_col) = occurrence[x].get_position(1)
                        self._set(i_row, i_col, x + 1)
         
        return self.hidden_single(retries - 1)

    # implements hidden pair solution strategy
    def hidden_pair(self):
        hits = 0
        
        for row in range(9): # loop through the rows
            occurrence = [Occurrence() for x in range(9)]
            
            for col in range(9): # loop through each column of the row
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list() # get candidates list for the cell
                
                    for elem in candidates:
                        occurrence[elem-1].increment() # increment candidate's counter
                        
                        cell_num = occurrence[elem-1].get_counter()
                        
                        if cell_num <= 2:
                            occurrence[elem-1].set_position(cell_num, row, col) # save cells' position (upto 2)
            
            for x in range(8): # loop through the Occurence
                x_count = occurrence[x].get_counter()
                x_pos1 = occurrence[x].get_position(1)
                x_pos2 = occurrence[x].get_position(2)
                
                if x_count == 2 : # if it's candidate for hidden pair
                    for y in range(x + 1, 9): # to find the pair
                        y_count = occurrence[y].get_counter()
                        y_pos1 = occurrence[y].get_position(1)
                        y_pos2 = occurrence[y].get_position(2)
                        
                        if y_count == 2 and \
                            x_pos1 == y_pos1 and \
                            x_pos2 == y_pos2: # a pair is found
                            
                            hits += 1
                            
                            (i_row, i_col) = x_pos1 # first cell
                            self.board[i_row][i_col].set(0) # clearing out the candidates list
                            self.board[i_row][i_col].add(x + 1) # add first candidate
                            self.board[i_row][i_col].add(y + 1) # add second candidate
                            
                            (i_row, i_col) = x_pos2 # second cell
                            self.board[i_row][i_col].set(0)
                            self.board[i_row][i_col].add(x + 1)
                            self.board[i_row][i_col].add(y + 1)
                                
        for col in range(9): # loop through the columns
            occurrence = [Occurrence() for x in range(9)]
            
            for row in range(9): # loop through each row of the column
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list()
                
                    for elem in candidates:
                        occurrence[elem-1].increment()
                        
                        cell_num = occurrence[elem-1].get_counter()
                        
                        if cell_num <= 2:
                            occurrence[elem-1].set_position(cell_num, row, col) # record positions
            
            for x in range(8):
                x_count = occurrence[x].get_counter()
                x_pos1 = occurrence[x].get_position(1)
                x_pos2 = occurrence[x].get_position(2)
                
                if x_count == 2 :
                    for y in range(x + 1, 9):
                        y_count = occurrence[y].get_counter()
                        y_pos1 = occurrence[y].get_position(1)
                        y_pos2 = occurrence[y].get_position(2)
                        
                        if y_count == 2 and \
                            x_pos1 == y_pos1 and \
                            x_pos2 == y_pos2:
                            
                            hits += 1
                            
                            (i_row, i_col) = x_pos1
                            self.board[i_row][i_col].set(0)
                            self.board[i_row][i_col].add(x + 1)
                            self.board[i_row][i_col].add(y + 1)
                            
                            (i_row, i_col) = x_pos2
                            self.board[i_row][i_col].set(0)
                            self.board[i_row][i_col].add(x + 1)
                            self.board[i_row][i_col].add(y + 1)
        
        for box_row in range(0, 9, 3): # loop throgh the 9 boxes
            for box_col in range(0, 9, 3):
                occurrence = [Occurrence() for x in range(9)]
            
                for row in range(box_row, box_row + 3): # loop through the rows of the 3X3 box
                    for col in range(box_col, box_col + 3): # loop through the columns of the 3X3 box
                        if self.board[row][col].is_empty():
                            candidates = self.board[row][col].list()

                            for elem in candidates:
                                occurrence[elem-1].increment()
                        
                                cell_num = occurrence[elem-1].get_counter()
                        
                                if cell_num <= 2:
                                    occurrence[elem-1].set_position(cell_num, row, col)
            
                for x in range(8):
                    x_count = occurrence[x].get_counter()
                    x_pos1 = occurrence[x].get_position(1)
                    x_pos2 = occurrence[x].get_position(2)
                
                    if x_count == 2 :
                        for y in range(x + 1, 9):
                            y_count = occurrence[y].get_counter()
                            y_pos1 = occurrence[y].get_position(1)
                            y_pos2 = occurrence[y].get_position(2)
                        
                            if y_count == 2 and \
                                x_pos1 == y_pos1 and \
                                x_pos2 == y_pos2:
                                
                                hits += 1
                            
                                (i_row, i_col) = x_pos1
                                self.board[i_row][i_col].set(0)
                                self.board[i_row][i_col].add(x + 1)
                                self.board[i_row][i_col].add(y + 1)
                            
                                (i_row, i_col) = x_pos2
                                self.board[i_row][i_col].set(0)
                                self.board[i_row][i_col].add(x + 1)
                                self.board[i_row][i_col].add(y + 1)
                                
        return hits // 2 # divide by 2 since we get 2 hits for each candidate
    
    # implements hidden triple solution strategy
    # this funciton is similar to hidden_pair except that it looks for group of three candidates
    def hidden_triple(self):
        hits=0
        
        for row in range(9):
            occurrence = [Occurrence() for x in range(9)]
            
            for col in range(9):
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list()
                
                    for elem in candidates:
                        occurrence[elem-1].increment()
                        
                        cell_num = occurrence[elem-1].get_counter()
                        
                        if cell_num <= 3:
                            occurrence[elem-1].set_position(cell_num, row, col)
            
            for x in range(7):
                x_count = occurrence[x].get_counter()
                x_pos1 = occurrence[x].get_position(1)
                x_pos2 = occurrence[x].get_position(2)
                x_pos3 = occurrence[x].get_position(3)
                
                if x_count == 3: 
                    for y in range(x + 1, 9):
                        y_count = occurrence[y].get_counter()
                        y_pos1 = occurrence[y].get_position(1)
                        y_pos2 = occurrence[y].get_position(2)
                        y_pos3 = occurrence[y].get_position(3)
                        
                        if y_count == 3 and \
                            x_pos1 == y_pos1 and \
                            x_pos2 == y_pos2 and \
                            x_pos3 == y_pos3:
                            
                            for z in range(y + 1, 9):
                                z_count = occurrence[z].get_counter()
                                z_pos1 = occurrence[z].get_position(1)
                                z_pos2 = occurrence[z].get_position(2)
                                z_pos3 = occurrence[z].get_position(3)
                                
                                if z_count == 3 and \
                                    y_pos1 == z_pos1 \
                                    and y_pos2 == z_pos2 and \
                                    y_pos3 == z_pos3:
                                    
                                    hits += 1
                                    
                                    (i_row, i_col) = x_pos1
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)
                                    
                                    (i_row, i_col) = x_pos2
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)

                                    (i_row, i_col) = x_pos3
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)
                                
        for col in range(9):
            occurrence = [Occurrence() for x in range(9)]
            
            for row in range(9):
                if self.board[row][col].is_empty():
                    candidates = self.board[row][col].list()
                
                    for elem in candidates:
                        occurrence[elem-1].increment()
                        
                        cell_num = occurrence[elem-1].get_counter()
                        
                        if cell_num <= 3:
                            occurrence[elem-1].set_position(cell_num, row, col)
            
            for x in range(7):
                x_count = occurrence[x].get_counter()
                x_pos1 = occurrence[x].get_position(1)
                x_pos2 = occurrence[x].get_position(2)
                x_pos3 = occurrence[x].get_position(3)
                
                if x_count == 3:
                    for y in range(x + 1, 9):
                        y_count = occurrence[y].get_counter()
                        y_pos1 = occurrence[y].get_position(1)
                        y_pos2 = occurrence[y].get_position(2)
                        y_pos3 = occurrence[y].get_position(3)
                        
                        if y_count == 3 and \
                            x_pos1 == y_pos1 and \
                            x_pos2 == y_pos2 and \
                            x_pos3 == y_pos3:
                            
                            for z in range(y + 1, 9):
                                z_count = occurrence[z].get_counter()
                                z_pos1 = occurrence[z].get_position(1)
                                z_pos2 = occurrence[z].get_position(2)
                                z_pos3 = occurrence[z].get_position(3)
                                
                                if z_count == 3 and \
                                    y_pos1 == z_pos1 and \
                                    y_pos2 == z_pos2 and \
                                    y_pos3 == z_pos3:
                                    
                                    hits += 1
                                    
                                    (i_row, i_col) = x_pos1
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)
                                    
                                    (i_row, i_col) = x_pos2
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)

                                    (i_row, i_col) = x_pos3
                                    self.board[i_row][i_col].set(0)
                                    self.board[i_row][i_col].add(x + 1)
                                    self.board[i_row][i_col].add(y + 1)
                                    self.board[i_row][i_col].add(z + 1)
                                    
        for box_row in range(0, 9, 3):
            for box_col in range(0, 9, 3):
                occurrence = [Occurrence() for x in range(9)]
            
                for row in range(box_row, box_row + 3):
                    for col in range(box_col, box_col + 3):
                        if self.board[row][col].is_empty():
                            candidates = self.board[row][col].list()

                            for elem in candidates:
                                occurrence[elem-1].increment()
                        
                                cell_num = occurrence[elem-1].get_counter()
                        
                                if cell_num <= 2:
                                    occurrence[elem-1].set_position(cell_num, row, col)
            
                for x in range(7):
                    x_count = occurrence[x].get_counter()
                    x_pos1 = occurrence[x].get_position(1)
                    x_pos2 = occurrence[x].get_position(2)
                    x_pos3 = occurrence[x].get_position(3)
                
                    if x_count == 3:
                        for y in range(x + 1, 9):
                            y_count = occurrence[y].get_counter()
                            y_pos1 = occurrence[y].get_position(1)
                            y_pos2 = occurrence[y].get_position(2)
                            y_pos3 = occurrence[y].get_position(3)
                        
                            if y_count == 3 and \
                                x_pos1 == y_pos1 and \
                                x_pos2 == y_pos2 and \
                                x_pos3 == y_pos3:
                                
                                for z in range(y + 1, 9):
                                    z_count = occurrence[z].get_counter()
                                    z_pos1 = occurrence[z].get_position(1)
                                    z_pos2 = occurrence[z].get_position(2)
                                    z_pos3 = occurrence[z].get_position(3)
                                
                                    if z_count == 3 and \
                                        y_pos1 == z_pos1 and \
                                        y_pos2 == z_pos2 and \
                                        y_pos3 == z_pos3:
                                        
                                        hits += 1
                                    
                                        (i_row, i_col) = x_pos1
                                        self.board[i_row][i_col].set(0)
                                        self.board[i_row][i_col].add(x + 1)
                                        self.board[i_row][i_col].add(y + 1)
                                        self.board[i_row][i_col].add(z + 1)
                                    
                                        (i_row, i_col) = x_pos2
                                        self.board[i_row][i_col].set(0)
                                        self.board[i_row][i_col].add(x + 1)
                                        self.board[i_row][i_col].add(y + 1)
                                        self.board[i_row][i_col].add(z + 1)

                                        (i_row, i_col) = x_pos3
                                        self.board[i_row][i_col].set(0)
                                        self.board[i_row][i_col].add(x + 1)
                                        self.board[i_row][i_col].add(y + 1)
                                        self.board[i_row][i_col].add(z + 1)
                                        
        return hits // 3
    
    # implements naked single solution strategy
    def naked_single(self):
        hits = 0
        
        for row in range(9):
            for col in range(9):
                if self.board[row][col].count() == 1: # cell with a single candidate
                    
                    hits += 1
                    
                    value = self.board[row][col].list()[0]
                    
                    self._set(row, col, value) # sets the cell's value to the single candidate
                    
        for col in range(9):
            for row in range(9):
                if self.board[row][col].count() == 1:
                    
                    hits += 1
                    
                    value = self.board[row][col].list()[0]
                    
                    self._set(row, col, value)

        return hits

    # implements naked pair solution strategy
    def naked_pair(self):
        hits = 0
        
        for row in range(9): # scan by rows
            for i_col in range(8):
                if self.board[row][i_col].count() == 2:
                    i_values = self.board[row][i_col].list()
                    
                    for j_col in range(i_col + 1, 9):
                        j_values = self.board[row][j_col].list()
                        
                        if self.board[row][j_col].count() == 2 and \
                            i_values == j_values: # if a pair is found in the specified row
                            
                            hits += 1
                            
                            self._clear_row(row, i_col, j_col, i_values) # remove these two candidates from
                                                                         # other cells of the row
                            
                            if i_col // 3 == j_col // 3: # if the cells belong to the same box
                                self._clear_box(row, i_col, row, j_col, i_values) # remove these two candidates
                                                                                  # from other cells of the box

        for col in range(9): # scan by columns
            for i_row in range(8):
                if self.board[i_row][col].count() == 2:
                    i_values = self.board[i_row][col].list()
                    
                    for j_row in range(i_row + 1, 9):
                        j_values = self.board[j_row][col].list()
                        
                        if self.board[j_row][col].count() == 2 and \
                            i_values == j_values: # a pair is found
                            
                            hits += 1
                            
                            self._clear_col(i_row, j_row, col, i_values) # remove the two candidates from the
                                                                         # other cells of the column
                            
                            if i_row // 3 == j_row // 3: # if the two cells belong to the same box
                                self._clear_box(i_row, col, j_row, col, i_values)
            
      
        for box_row in range(0, 9, 3): # scan through each of the 9 boxes
            for box_col in range(0, 9, 3):
                for i_row in range(box_row, box_row + 3): # scan through cells of each 3X3 box
                    for i_col in range(box_col, box_col + 3):
                        if self.board[i_row][i_col].count() == 2:
                            i_values = self.board[i_row][i_col].list()
                            
                            for j_row in range(box_row, box_row + 3):
                                for j_col in range(box_col, box_col + 3):
                                    j_values = self.board[j_row][j_col].list()
                                    
                                    if j_row != i_row and \
                                        j_col != i_col and \
                                        self.board[j_row][j_col].count() == 2 and \
                                        i_values == j_values: # a naked pair is found
                                        
                                        hits += 1
                                        
                                        # remove the two candidates from other cells of the box
                                        self._clear_box(i_row, i_col, j_row, j_col, i_values) 
                                        
                                        # remove the two candidates from the other cells of the row if
                                        # they belong to the same row
                                        if i_row == j_row:
                                            self._clear_row(i_row, i_col, j_col, i_values)
                                            
                                        # remove the two candidates from the other cells of the column if
                                        # they belong to the same column
                                        if i_col == j_col:
                                            self._clear_col(i_row, j_row, i_col, i_values)
                
        return hits

    # clears the candidate from other cells of the row
    def _clear_row(self, row, col1, col2, values):
        for col in range(9):
            if col != col1 and \
                col != col2 and \
                self.board[row][col].is_empty():
                
                for value in values:
                    self.board[row][col].delete(value)

    # clears the candidate from other cells of the column
    def _clear_col(self, row1, row2, col, values):
        for row in range(9):
            if row != row1 and \
                row != row2 and \
                self.board[row][col].is_empty():    
                
                for value in values:
                    self.board[row][col].delete(value)

    # clears the candidate from other cells of the box
    def _clear_box(self, row1, col1, row2, col2, values):
        for row in range(row1 // 3 * 3, row1 // 3 * 3 + 3):
            for col in range(col1 // 3 * 3, col1 // 3 * 3 + 3):
                if (row, col) != (row1, col1) and \
                    (row, col) != (row2, col2) and \
                    self.board[row][col].is_empty():
                        
                        for value in values:
                            self.board[row][col].delete(value)

# Program starts here
# just for testing                            
board9 = Board([[3,0,6,5,0,8,4,0,0],
               [5,2,0,0,0,0,0,0,0],
               [0,8,7,0,0,0,0,3,1],
               [0,0,3,0,1,0,0,8,0],
               [9,0,0,8,6,3,0,0,5],
               [0,5,0,0,9,0,6,0,0],
               [1,3,0,0,0,0,2,5,0],
               [0,0,0,0,0,0,0,7,4],
               [0,0,5,2,0,6,3,0,0]
              ]
             )

board1 = Board([[8,2,1,'*','*','*','*','*',7],
               ['*','*','*',8,'*','*','*',6,'*'],
               ['*',6,'*',9,3,'*','*','*',5],
               ['*','*',8,2,'*',1,6,'*','*'],
               ['*','*','*',7,'*','*',2,8,4],
               [2,4,'*',6,'*',3,7,'*','*'],
               [6,'*',5,'*','*','*',1,'*',3],
               ['*',7,'*','*',5,'*','*','*','*'],
               [9,1,2,'*','*','*','*','*',6]
              ]
             )

board2 = Board([[5,3,'*','*',7,'*','*','*','*'],
                [6,'*','*',1,9,5,'*','*','*'],
                ['*',9,8,'*','*','*','*',6,'*'],
                [8,'*','*','*',6,'*','*','*',3],
                [4,'*','*',8,'*',3,'*','*',1],
                [7,'*','*','*',2,'*','*','*',6],
                ['*',6,'*','*','*','*',2,8,'*'],
                ['*','*','*',4,1,9,'*','*',5],
                ['*','*','*','*',8,'*','*',7,9]
              ]
             )

print("Initial")
board2.print()
board2.print_candidates()
#retries = 10

#print(f"Solved Sudoku by Hidden Single technique in {retries - board.hidden_single(retries)} iterations!")
#print(f"Number of hits in hidden pair - {board.hidden_pair()}")
#print(f"Number of hits in hidden triple - {board.hidden_triple()}")
board2.hidden_single(1)
#board.print()
#board.print_candidates()
board2.naked_pair()
#board.print_candidates()
board2.hidden_single(1)
#board.print_candidates()
board2.naked_single()
#board.print_candidates()
board2.hidden_pair()
board2.hidden_triple()
board2.naked_pair()
board2.print()
board2.print_candidates()
